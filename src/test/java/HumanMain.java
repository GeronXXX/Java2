import java.util.*;

public class HumanMain {
    /**
     * Массивы. В java массивы имеют всегда фиксированную длину и эта длина не может изменяться в процессе жизни массива.
     */

    public static void main(String[] args) {
        String[] hobbies = new String[3];
        hobbies[0] = "Футбол";
        hobbies[1] = "Java";
        hobbies[2] = "Гражданская Оборона";

/** Есть способ как будто бы мы не знаем длину массива, и как будто бы мы её не указываем.
 * В действительность в этом случаи java пересчитывает сколько указано строчек, понимает, что их три, создаётся
 * масив длиной в три, туда присваиваются эти значения и всё дальше эта длина не изменяется.
 * По сути одно и тоже, что и код выше.
 * У Массива нет своих поведения, короме как узнать его длину. Есть так наззываемые "стримы". На самом деле стрим
 * IDEA оборачивает статического метода stream у класса Arrays пример - Arrays.stream(hobbiesAnother).count()
 * Подробнее о методах работы с массивами https://www.digitalocean.com/community/tutorials/java-array-contains-value
 * Минусы массива - это точ, что нужно изначально знеать его длину. */

        String[] hobbiesAnother = new String[]{
                "Футбол", "Java", "Гражданская Оборона"
        };
/** Синтаксис массива состоит в том, что мы указываем тип данных и квадратные скобки (пример String[]) и по сути
 * массива сам является типом данных. И можно создать массив массивов как это указано ниже. */

        int[][][] intArray = new int[][][]{
                new int[][]{
                        new int[]{1, 2, 3}
                },
                new int[][]{
                        new int[]{1, 2, 3}
                }
        };

        int length = hobbiesAnother.length;

/**За место массивов в тестировании чаще используется "java collections api". Допустим selenide element collections "$"
 * или "$$" используют "java collections api" а именно надстройка над "element collections list". В java несколько
 * коллекций и досталочно знать три "list", "Set", "Map" -это интерфейс, это не настоящая коллекция, это просто описание
 * её поведения.
 * Что нужно знать про все коллекции - это точ то они не поддерживают примитивные типы данных, но можно использовать
 * классы обёртки
 * Integer aIntegerWrapper;// int
 * Double aDoubleWrapper; // double
 * Character aCharWrapper; // char

 * - ArrayList - это самая популярная и эффективная
 * В отличии от простого массива он динамически может его копирывать в другой массив и создовать новый, там выделяется
 * маасив 10 элементов, как только добавили 11, он скапирует эти 10 в новый массив и добавит туда 11, это будет
 * настолько быстро, что это будет незаметно.
 * Для нас List - это просто обычный список, туда можно положить одинаковые объекты, его можно сортировать, выбрать
 * метод по которому будет сортировка, в нём можно искать объекты, в нём можно удалять объекты и многое др.
 * Этому List всё равно с каким типом данных работать */

        List<String> hobbiesList = new ArrayList<>();
        hobbiesList.add("Футбол");
        hobbiesList.add("Java");
        hobbiesList.add("Гражданская Оборона");

/** Это второй способ как можно стоздать List */

        List<String> hobbiesListAnother = List.of(
                "Футбол", "Java", "Гражданская Оборона"
        );
/** в Java есть понятие эквиволентность - означает логическую эквиволентность объектов. За определение этой
 *  эквививолентности отвечает метот equals, который есть у любого объекта, поскольку объект получает его с класса
 *  object. И на самом деле в методе equals проверяется адреса в памяти, то есть если мы создали два одинаковых объекта
 *  как это выгляди ниже, это физически два разных адреса в памяти, если есть слово new.
 *  На методе equals и на методе hashCode (у каждого объекта по мимо equals есть ещё hashCode) строится уникальность
 *  этого объекта.
 *  Для хеш сета объекты будут читаться одинаковыми, если результат работы equals одинаковый, то есть
 *  equals 1 и equals 2 = true и у которых одинаковая хеш функция по методу щитаному хеш кода.
 *  Как это работает, метод хеш код обязани возвращать одинаковое значение для объектов, для которых если сравнивается
 *   два equals и они равно true, equals = true
 *  Если для двух объектов equals = true то и хеш hash code будет одинаковый. Если hash code разные, то может быть такое
 *  что объекты всё равно одинаковые по equals - это называется колизия, такого не должно быть.
  */

        Human dima = new Human("Дима", 33, hobbies);
        Human dima1 = new Human("Дима", 33, hobbies);

/** Set - это множество уникальных объектов, то есть нельзя добавлять два одинаковых объекта, допустим два "Футбола".
 * Уникальность значения определяется по методу equals и hashCode. Для того, что бы этот метод работал правильно,
 * меттоды equals и hashCode должны быть согласованны в том смысле, что для результата истености equals всегда должен
 * быть одинаковый hashCode у двух объектов.
 */

        Set<Human> hobbiesSet = new HashSet<>();
        hobbiesSet.add(dima);
        hobbiesSet.add(dima1);
/** Это второй способ как можно стоздать Set */
        Set<String> hobbiesSetAnother = Set.of(
                "Футбол", "Java", "Гражданская Оборона"
        );

/** Колекция Map которая реализует ключь-значение. Колекции Map хронит объекты привязав к кокомуто ключу, примерно
 * так же как в БД определение по id ключу. Позволяет работать очень быстро с данными, если знать ключ */
        Map<String, Human> humans = new HashMap<>();
        humans.put("1234545", dima);
        humans.put("1224455", dima1);

/** С масивами или java collections api удобнее работать с помощью цикла.
 * Циклы в джаве бывают четырёх видов. Первый это цикл с индексом i, его удобно спользовать с масивами.
 * "int i = 0"; - с какого индекса начинается цикл. "i < hobbies.length;" - указания условия по которому нужно выйти
 * из цикла, с циклов нужно выходить, иначе цикл будет гоняться покругу и просто всё зависнит, само выражение значт, что
 * цикл прикратиться когда цикл станет меньше длины массива; То есть масив длиной 3, то цикл прикроатиться когда индекс
 * станет больше 2, то цикл прикратиться. i++ - вырожение по
 * которому изменяется цикл, ++ - значит, что будем прибовлять еденицу, то есть после выражения "i < hobbies.length;"
 * прибавится ещё еденица, тем самым провериться последний индекс и цикл перестанет работать*/

        for (int i = 0; i < hobbies.length; i++) {
            System.out.println(hobbies[i]);
        }
/** Цикл "for". "(String hobby : hobbies)" справа источник данных "String hobby", а слева "hobbies" вид данных данных
 * которые мы получим от источника. Такой цикл позволит последовательно перебрать все элементы массива или коллекции.
 * Он закончится тогда, когда закончится объекты в коллекции или массиве*/

        for (String hobby : hobbies) {
            System.out.println(hobby);
        }
/** Цикл "while" если нужно найти в массиве какойто определённый объект. Можно конечно использовать такой выражение
 * "asList(Hobbies).contains("Java");", но в некоторых случаях лучше использовать цикл "while".
 * Цикл работает пока выражение в этих скобках "(!arrayContainJava && index < hobbies.length)" является true,  где знак
 * "!" - является отрецанием.
 * В java нельзя выходить за пределы массива, то есть нужно указывать его придел после чего цикл прикратиться, выражение
 * "&& index < hobbies.length)", где "&&" зчит "И", "index < hobbies.length" значит, что индекс должен быть меньше
 * длины массива*/
        boolean arrayContainJava = false;
        int index = 0;
        while (!arrayContainJava && index < hobbies.length) {
            if (hobbies[index].equals("Java")) {
                arrayContainJava = true;
                return;
            }
            index++;
        }

/** "do while" отличается от "while" почти ничем. Только разница в том, что цикл может выполница ни разу.  */
        do {
            if (hobbies[index].equals("Java")) {
                arrayContainJava = true;
            }
            index++;
        } while (!arrayContainJava && index < hobbies.length);

    }
}
/** Еще одно важная вещь про циклах - это то, что из циклов можно выходить или прирывать их некоторыми ключивыми словами.
 * Допустим ключиваое слово "break;" - если найдёт необходимый объект цикл прикратиться. Ключивое слова "continue;" -
 * значит, что он завершает текущую интерацию, но следующая будет выполняться; Тоесть когда дальше эту итерацию смысла
 * выполнять дальше нет, но продолжить следующую. Ключивое слово "return:" - слово допустимо в любом месте метода, но
 * оно заверает весь метод циликом, то есть будет завершен работа всего метода Main
 */
